

Innodb采用乐观插入的方式，所以在做insert操作时不会进行显示加锁，也就是不会生成lock_t锁结构，这样可以极大的减少锁开销，提升整体的性能。

如果没有显示的行锁，该如何保证事务插入的正确性呢？比如说如下两个事务，插入相同的两个主键数据

# InnoDB数据行结构

行结构中，除了用户定义的列外还有3个系统列：DATA_ROW_ID、DATA_TRX_ID、DATA_ROLL_PTR，如果表没有定义主键那么DATA_ROW_ID作为主键列，否则行结构中没有DATA_ROW_ID列。其中：

DATA_TRX_ID:修改该行数据的事务的ID

DATA_ROLL_PTR：指向该行回滚段的指针。


Innodb的行锁结构是基于行数据的，而隐式锁没有真正的行锁结构，它通过每一行数据的隐藏字段来完成。

Innodb主键索引的每一行数据包含两个隐藏列，其中一个是trx_id,另外一个是回滚段指针。
而主键索引上的隐式锁就是通过trx_id来进行设置的，
二级索引上的行数据没有trx_id，
但是每一个数据页上包含一个max_trx_id;


# 隐式锁加锁流程
在开始研究Insert加锁流程时，一直没看出来是如何操作的，因为在进入加锁代码逻辑中，没有看到设置行数据trx_id的过程。这个过程其实实在之前完成的，在构建Innondb 行数据的时候，就已经把trx_id设置进去了。

InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于簇索引的B+Tree中。
假设只有主键索引，则在进行插入时，行数据的trx_id被设置为当前事务id
假设存在二级索引，则在对二级索引进行插入时，需要更新所在page的max_trx_id.


# 判断是否存在隐式锁

对于主键而言，隐式锁的判断只需要查看当前行数据的隐藏列 trx_id是否是活跃事务即可。

对于二级索引会比较麻烦

假设R1是二级索引数据，想要检测R1上是否存在其他的事务拥有隐式锁
获取R1所在的数据页的最大事务ID T1
假设T2是当前事务系统中的最小活跃事务id，如果T1


# 隐式锁转换
只有在特殊情况下，才会发生隐式锁到显示锁的转换。这个转换动作并不是加隐式锁的线程自发去做的，而是其他存在行数据冲突的线程去做的。