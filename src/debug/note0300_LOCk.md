
1 从插入语句分析 加锁的过程  


2 分析一个死锁的案列   
https://mp.weixin.qq.com/s/b9gNbdEHV3NNQrV9PKDPSw

3 分析出各种锁的加锁机制    
https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html

4 幻读 的 分析



一次实践的过程：

经过搜集资料 和 初次试验之后，感觉很混乱，想了解锁的机制又无从下手了

进行了分析，现在有的资源， 几个死锁的案列， 会调试源代码，可以找到在哪里加了锁，可以砸资源代码中找到问题


整理了一下要做的事情
1 整理各种锁的类型
2 整理各种锁的模式
3 每种锁单一出现的情况
4 几种锁在不同的会话，线程中出现，组合的时候回出现什么情况， 就是死锁分析，案例
6 特别分析一下间隙锁 和 读写锁

如果组合起来情况就会特别多，所以要找出特例， 具体分析出一种情况的完整过程
（你不可能知道每种情况， 但是要知道遇到某一种情况怎么分析和怎么解决）


做这件事情的意义是什么， 生产，为了在工作中提高效率，优化资源，就找出工作中常遇到的情况 

解决这个问题的办法
1 怎么避免死锁
2 当死锁出现的时候怎么去解决死锁 不至于生产上造成不可用， 也要让损失减少到最小
比如超时机制


思考  
为什么要用锁， 用锁解决了什么问题       -->   解决并发的问题，提高并发的同时，保证数据一致性，数据一致性是数据库的底线 （包括后来的最终一致性理论）
用了锁又带来了什么问题                -->   死锁 对公司和用户造成利益上的损失
怎么解决死锁的问题                   -->   设置超时机制，和别的方案，超时的时间多少合适 ，回滚。。。。

数据库的死锁，也是所线程，去争夺资源，或者说因为共享的原因引起的  

这和java jvm 中的多线程 加锁 的 本质 是一样的 jvm中 java 中是怎么解决 锁的问题
java并发变成  中的锁 是是为了解决 三大并发问题（原子性，可见性， 有序性）中的原子性的问题

然而jvm是个进程 里边有多线程去操作共享资源 产生的问题 加锁解决 
这和mysql这个进程 里边有多个线程去操作共享的行内容的时候是一致的 都会产生死锁的问题

本质上来看是一模一样的，在深一层就是操作系统中的两个线程 中 有多个线程 发生了类似的问题 两个人的解决方案怎么样呢 ，
据说数据库甩了jvm几条街 事实是什么样的呢

一定，一定，一定 用源代码 调试 一个案例，并且做详细的记录 ，程序员最重要的就是实践出来，也就是有没有生产出来，有没有实践的经验，有没有采坑。




















